// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mocks

import (
	"github.com/mouad-eh/wasseet/proxy/config"
	"github.com/mouad-eh/wasseet/request"
	"net/http"
	"sync"
)

// Ensure, that RequestOperationMock does implement config.RequestOperation.
// If this is not the case, regenerate this file with moq.
var _ config.RequestOperation = &RequestOperationMock{}

// RequestOperationMock is a mock implementation of config.RequestOperation.
//
//	func TestSomethingThatUsesRequestOperation(t *testing.T) {
//
//		// make and configure a mocked config.RequestOperation
//		mockedRequestOperation := &RequestOperationMock{
//			ApplyFunc: func(req request.ServerRequest)  {
//				panic("mock out the Apply method")
//			},
//		}
//
//		// use mockedRequestOperation in code that requires config.RequestOperation
//		// and then make assertions.
//
//	}
type RequestOperationMock struct {
	// ApplyFunc mocks the Apply method.
	ApplyFunc func(req request.ServerRequest)

	// calls tracks calls to the methods.
	calls struct {
		// Apply holds details about calls to the Apply method.
		Apply []struct {
			// Req is the req argument value.
			Req request.ServerRequest
		}
	}
	lockApply sync.RWMutex
}

// Apply calls ApplyFunc.
func (mock *RequestOperationMock) Apply(req request.ServerRequest) {
	callInfo := struct {
		Req request.ServerRequest
	}{
		Req: req,
	}
	mock.lockApply.Lock()
	mock.calls.Apply = append(mock.calls.Apply, callInfo)
	mock.lockApply.Unlock()
	if mock.ApplyFunc == nil {
		return
	}
	mock.ApplyFunc(req)
}

// ApplyCalls gets all the calls that were made to Apply.
// Check the length with:
//
//	len(mockedRequestOperation.ApplyCalls())
func (mock *RequestOperationMock) ApplyCalls() []struct {
	Req request.ServerRequest
} {
	var calls []struct {
		Req request.ServerRequest
	}
	mock.lockApply.RLock()
	calls = mock.calls.Apply
	mock.lockApply.RUnlock()
	return calls
}

// Ensure, that ResponseOperationMock does implement config.ResponseOperation.
// If this is not the case, regenerate this file with moq.
var _ config.ResponseOperation = &ResponseOperationMock{}

// ResponseOperationMock is a mock implementation of config.ResponseOperation.
//
//	func TestSomethingThatUsesResponseOperation(t *testing.T) {
//
//		// make and configure a mocked config.ResponseOperation
//		mockedResponseOperation := &ResponseOperationMock{
//			ApplyFunc: func(resp *http.Response)  {
//				panic("mock out the Apply method")
//			},
//		}
//
//		// use mockedResponseOperation in code that requires config.ResponseOperation
//		// and then make assertions.
//
//	}
type ResponseOperationMock struct {
	// ApplyFunc mocks the Apply method.
	ApplyFunc func(resp *http.Response)

	// calls tracks calls to the methods.
	calls struct {
		// Apply holds details about calls to the Apply method.
		Apply []struct {
			// Resp is the resp argument value.
			Resp *http.Response
		}
	}
	lockApply sync.RWMutex
}

// Apply calls ApplyFunc.
func (mock *ResponseOperationMock) Apply(resp *http.Response) {
	callInfo := struct {
		Resp *http.Response
	}{
		Resp: resp,
	}
	mock.lockApply.Lock()
	mock.calls.Apply = append(mock.calls.Apply, callInfo)
	mock.lockApply.Unlock()
	if mock.ApplyFunc == nil {
		return
	}
	mock.ApplyFunc(resp)
}

// ApplyCalls gets all the calls that were made to Apply.
// Check the length with:
//
//	len(mockedResponseOperation.ApplyCalls())
func (mock *ResponseOperationMock) ApplyCalls() []struct {
	Resp *http.Response
} {
	var calls []struct {
		Resp *http.Response
	}
	mock.lockApply.RLock()
	calls = mock.calls.Apply
	mock.lockApply.RUnlock()
	return calls
}
